# CI/CD recipes for GitHub Actions and local development
# These recipes ensure local-CI parity: run the same commands locally as in CI

# Validate shell scripts with ShellCheck and shfmt
lint-shell:
  #!/usr/bin/env bash
  set -euo pipefail
  echo "ğŸ” Running ShellCheck..."
  shellcheck --severity=warning **/*.sh
  echo "âœ… ShellCheck passed"

  echo "ğŸ” Checking shell formatting..."
  shfmt -d -i 2 -ci -bn **/*.sh
  echo "âœ… Shell formatting check passed"

# Lint and type-check Python scripts
lint-python:
  #!/usr/bin/env bash
  set -euo pipefail
  echo "ğŸ” Running ruff linter..."
  uvx ruff check .
  echo "âœ… Ruff linting passed"

  echo "ğŸ” Running ruff format check..."
  uvx ruff format --check .
  echo "âœ… Ruff formatting check passed"

  echo "ğŸ” Running mypy type checker..."
  uvx mypy scripts/*.py --strict
  echo "âœ… Mypy type checking passed"

# Validate markdown files with rumdl (Rust) and check links with lychee (Rust)
lint-markdown:
  #!/usr/bin/env bash
  set -euo pipefail
  echo "ğŸ” Running rumdl..."
  uvx rumdl check .
  echo "âœ… Markdown linting passed"

  echo "ğŸ” Checking links with lychee..."
  lychee --config lychee.toml .
  echo "âœ… Link checking passed"

# Run integration tests in Docker container (requires Docker/Podman)
test-install:
  #!/usr/bin/env bash
  set -euo pipefail
  echo "ğŸ§ª Running integration tests in Arch Linux container..."

  # Check if docker or podman is available
  if command -v docker &> /dev/null; then
    CONTAINER_CMD="docker"
  elif command -v podman &> /dev/null; then
    CONTAINER_CMD="podman"
  else
    echo "âŒ Neither docker nor podman found. Please install one of them."
    exit 1
  fi

  echo "Using container runtime: $CONTAINER_CMD"

  $CONTAINER_CMD run --rm -v "$(pwd):/workspace" -w /workspace archlinux:latest /bin/bash -c '
    set -e
    echo "ğŸ“¦ Installing dependencies..."
    pacman -Sy --noconfirm git bats just base-devel

    echo "ğŸ—ï¸  Creating test repository..."
    mkdir -p /tmp/test-repo
    cd /tmp/test-repo
    git init
    git config user.name "Test User"
    git config user.email "test@example.com"

    echo "ğŸ“¥ Running install script..."
    bash /workspace/install.sh

    echo "âœ… Running installation tests..."
    bats /workspace/tests/integration/test-install.bats

    echo "ğŸ—‘ï¸  Running uninstall script..."
    bash /workspace/uninstall.sh --force

    echo "âœ… Running uninstall tests..."
    bats /workspace/tests/integration/test-uninstall.bats
  '

  echo "âœ… Integration tests passed"

# === Release Management Recipes ===

# Generate or update CHANGELOG.md using git-cliff (Rust-based)
changelog:
  #!/usr/bin/env bash
  set -euo pipefail
  echo "ğŸ“ Generating changelog with git-cliff..."
  git-cliff --config cliff.toml --output CHANGELOG.md
  echo "âœ… Changelog generated"

# Generate release notes for a specific tag (Argo-compatible: no GitHub dependency)
release-notes TAG:
  #!/usr/bin/env bash
  set -euo pipefail

  # Validate semantic version tag format
  if [[ ! "{{TAG}}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "âŒ Invalid tag format: {{TAG}}" >&2
    echo "Expected format: v1.2.3" >&2
    exit 1
  fi

  # Generate changelog for this version only
  git-cliff --config cliff.toml --unreleased --tag "{{TAG}}" --strip all

# Create GitHub release using gh CLI (works locally and in any CI)
github-release TAG:
  #!/usr/bin/env bash
  set -euo pipefail

  # Validate tag format first
  just release-notes "{{TAG}}" > /dev/null

  echo "ğŸ“ Generating release notes with git-cliff..."
  NOTES=$(just release-notes "{{TAG}}")

  echo "ğŸš€ Creating GitHub release for {{TAG}}..."
  gh release create "{{TAG}}" \
    --title "Release {{TAG}}" \
    --notes "$NOTES" \
    install.sh uninstall.sh

  echo "âœ… Release {{TAG}} created with assets"

# Full release workflow (for local testing)
release TAG: (release-notes TAG) (github-release TAG)
  @echo "âœ… Release {{TAG}} complete"
